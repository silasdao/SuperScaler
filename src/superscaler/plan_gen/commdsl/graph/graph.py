# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

from superscaler.plan_gen.commdsl.graph.node import Node, TransNode, CompNode
from superscaler.plan_gen.commdsl.graph.meta import TransNodeType
from superscaler.plan_gen.commdsl.graph.meta import CompNodeType
from superscaler.plan_gen.commdsl.errors import CommDSLRuntimeError
import numpy as np
import scipy.sparse as spsp


class CommGraph:
    """
    Dependency graph of trans/comm nodes,
    which includes send/recv primitives and data segment ops.,

    An instance of CommGraph corresponds to a
    dependency graph on a specific rank.

    Nodes in CommGraph starts with an empty node.

    Attributes:
        nodes (List[Node]): nodes in declared (program) order
        __adj (numpy.array): dependency matrix, with shape of
            (len(self.nodes), len(self.nodes))
    """

    def __init__(self):
        # the first empty Node indicates for the start node
        self.__nodes = [Node()]
        self.__adj = None

    @property
    def nodes(self):
        return self.__nodes

    @nodes.setter
    def nodes(self, nodes):
        if not all(isinstance(node, Node) for node in nodes):
            raise TypeError("Expected to be a list of nodes")
        self.__nodes = nodes

    @property
    def adj(self):
        return self.__adj

    @adj.setter
    def adj(self, val):
        raise CommDSLRuntimeError("Adj should be generated by gen_graph")

    def add_op(self, node):
        """
        Add operation node to this graph. Node will be assigned with a
        unique name in its graph

        Args:
            node (Node)
        """
        count = self.get_node_count(conds=dict(op=node.op))
        node.name = f'{node.op.value}_{str(count)}'
        self.nodes.append(node)

    def remove_op(self, node, update_graph=True):
        """
        Remove an operation node on this graph.

        Args:
            node (Node): node to remove
            update_graph (Boolean): whether update the adj

        Returns:
            None
        """
        if node not in self.nodes:
            raise CommDSLRuntimeError(
                "The node trying to delete is not in graph")
        nid = self.nodes.index(node)
        # remove node from partial nodes
        self.nodes.remove(node)
        # remove node from graph adj
        if self.__adj is not None and update_graph:
            # remove dependency from this node
            self.__adj = np.delete(self.__adj, nid, 0)
            # remove dependency to this node
            self.__adj = np.delete(self.__adj, nid, 1)

    def gen_graph(self):
        """
        Generate dependency graph. `adj` attribute will be set.

        Args:
            None

        Returns:
            None
        """
        op_num = len(self.nodes)
        adj = np.zeros((op_num, op_num), dtype=np.int8)
        root = 0  # root is an empty start node
        for nid, node in enumerate(self.nodes):
            no_dependency = True
            for prev_nid, prev_node in enumerate(self.nodes[:nid]):
                if node.depend_on(prev_node):
                    adj[prev_nid, nid] = 1
                    no_dependency = False
            if no_dependency:
                adj[root, nid] = 1
        self.__adj = adj

    def depend_nodes(self, node=None, nid=None):
        """
        Return the list of nodes which should be firstly executed before
        this the execution of this `node` in 1-hop.

        Choose one of `node` and `nid` to specify.
        If both of them are specified, will check whether they are matched.

        Args:
            node (Node)
            nid (int): node index in partial_node.

        Returns:
            nodes (List[Node]),
            nodes_id (List[Integer])
        """
        assert (isinstance(node, Node) or isinstance(nid, int)),\
            "Error: node should be Node or nid should be int"
        if isinstance(node, Node):
            if isinstance(nid, int):
                assert (self.nodes.index(node) == nid),\
                    "Error: node donesn't mathc with nid"
            else:
                nid = self.nodes.index(node)
        # get one-hop in-neighbor
        nodes_id = np.nonzero(self.__adj[:, nid])[0]
        nodes = [self.nodes[nid] for nid in nodes_id]
        return nodes, nodes_id

    def succ_nodes(self, node=None, nid=None):
        """
        Return the list of nodes which should wait for
        `self` node execution in 1-hop.

        Choose one of `node` and `nid` to specify.
        If both of them are specified, will check whether they are matched.

        Args:
            node (Node)
            nid (int): node index in partial_node.

        Returns:
            nodes (List[Node]),
            nodes_id (List[Integer])
        """
        assert (isinstance(node, Node) or isinstance(nid, int)),\
            "Error: node should be Node or nid should be int"
        if isinstance(node, Node):
            if isinstance(nid, int):
                assert (self.nodes.index(node) == nid),\
                    "Error: node donesn't mathc with nid"
            else:
                nid = self.nodes.index(node)
        # get one-hop out-neighbor
        nodes_id = np.nonzero(self.__adj[nid, :])[0]
        nodes = [self.nodes[nid] for nid in nodes_id]
        return nodes, nodes_id

    def visualize(self):
        """
        Visualize the depdendency graph
        """
        import networkx as nx
        import matplotlib.pyplot as plt
        assert (self.__adj is not None),\
            "Error: Trying to plot an un-initialized graph"
        g = nx.from_numpy_matrix(self.__adj, create_using=nx.DiGraph)
        color_map = []
        for node in self.nodes:
            color = 'red'
            if isinstance(node, TransNode):
                color = 'orange'
                if node.op == TransNodeType.RECV:
                    if node.reduction != CompNodeType.COPY:
                        color = 'blue'
            elif isinstance(node, CompNode):
                color = 'green'
            color_map.append(color)
        pos = nx.shell_layout(g)
        nx.draw(g, arrows=True, with_labels=True,
                node_color=color_map, pos=pos)
        plt.show()

    def get_node_count(self, last=None, conds=None):
        """
        Return the node number which matches the `conds`
        from start to `last` (included)
        in program specified order.

        E.g., if have node list [node1, node2, node3],
        will return 3 if node == node3 and conds is None.

        If only the node 2 has the same op type of node3,
        will return 2 if node == node3 and conds is {op=node.op}

        If last is None and conds is None, will return the node number.

        Args:
            node (Node or None): target node. If None, will go through
                all the nodes
            conds (dict{str: val}):
                If not none, only consider the nodes that match
                with the attrs specified in conds. Each key
                in conds is the attr name, each val is the
                condition.

        Returns:
            count (int), starting from 0

            Return 0 means conds doesn't match any nodes including `node`.
        """
        if last is None:
            last = self.nodes[-1]
        elif last not in self.nodes:
            raise CommDSLRuntimeError(f"Node {last} doesn't find in the graph")
        if conds is None:
            return self.nodes.index(last) + 1
        count = 0
        for iter_node in self.nodes:
            if iter_node.match_conds(conds):
                count += 1
            if iter_node == last:
                break
        return count

    def get_node(self, count, conds=None):
        """
        Get the `count`-th node given the conditions, in the order of
        program specified oder. If conds specified,
        will only consider the nodes which match with the conds.

        Args:
            count (int): count number, starts from 1
            conds (dict{str: val}):
                If not none, only consider the nodes that match
                with the attrs specified in conds. Each key
                in conds is the attr name, each val is the
                condition.

        Returns:
            node (Node) if find, None if not find
        """
        if count < 1 or count >= len(self.nodes):
            raise CommDSLRuntimeError(
                "Try to find a node out of boundary")
        if conds is None:
            return self.nodes[count]
        for node in self.nodes[1:]:
            if node.match_conds(conds):
                count -= 1
            if count == 0:
                break
        return None if count != 0 else node

    def __repr__(self):
        """
        Graph information string. will be automatically called
        when using `print()` to print the instance of CommGraph.

        Args:
            None

        Returns:
            strs (str): the output information string.
        """
        strs = 'partial op list: '
        for idx, node in enumerate(self.nodes):
            strs += f'\n{idx}: {node}'
        if self.__adj is not None:
            coo_matrix = spsp.coo_matrix(self.__adj)
            row, col = coo_matrix.row, coo_matrix.col
            strs += '\ndependency list:\n'
            row_id = 0
            for (op_id1, op_id2) in zip(row, col):
                if op_id1 != row_id:
                    row_id = op_id1
                    strs += '\n'
                strs += '{:2} -> {:2}  '.format(op_id1, op_id2)
        else:
            strs += '\n======\nGraph has not been built.'
        return strs
